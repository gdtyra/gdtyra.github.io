
    <!DOCTYPE html>
    <html>
    <head>
        <link rel="stylesheet" href="style.css?v=1762831290.6753502" />
        <link rel="stylesheet" href="vim.css?v=1762831290.6753502" />
        <title>gdtyra :: C++ Cheat Sheet</title>
    </head>
    <body>
    <div id="main">
    <div id ="nav" class="column">
    <nav>
    <h1>Table of Contents</h1>
    <ul>
  <li><a href="#c-cheat-sheet">C++ Cheat Sheet</a>
  <ul>
    <li><a href="#stl-algorithms">STL Algorithms</a></li>
    <li><a href="#stl-modifying-algorithms">STL Modifying Algorithms</a></li>
    <li><a href="#random">Random</a></li>
    <li><a href="#variants-and-optional">Variants and optional</a></li>
    <li><a href="#iterators">Iterators</a></li>
    <li><a href="#threading">Threading</a></li>
  </ul></li>
</ul>

    <h1>Other Pages</h2>
    <ul><li><a href="command_reference.html">Command Reference</a></li><li><a href="cpp_cheat_sheet.html">C++ Cheat Sheet</a></li><li><a href="cpp_templates_and_metaprogramming.html">C++ Templates and Metaprogramming</a></li><li><a href="data_migrations.html">Data Migrations</a></li><li><a href="deep_dives.html">Potential Deep Dives</a></li><li><a href="distributed_systems.html">Distributed Systems</a></li><li><a href="etymologies.html">Interesting Etymologies</a></li><li><a href="jargon_file.html">Jargon File</a></li><li><a href="software_design.html">Software Design</a></li><li><a href="things_of_interest.html">Things of Interest</a></li></ul>
    </nav>
    </div>
    <div class="column">
    <div id="content">
    <article>
    <h1 id="c-cheat-sheet">C++ Cheat Sheet</h1>

<h2 id="stl-algorithms">STL Algorithms</h2>

<ul>
<li><code>std::accumulate(first, last, initial, [op])</code>: perform summation on a range, optionally with given binary operation.</li>
<li><code>std::reduce(first, last, [initial, [op]])</code>: perform summation on a range, optionally with given initial value and binary operation.</li>
<li><code>std::transform_reduce(first, last, initial, biop, uop)</code>: perform the given unary operation followed by a binary operation on a range.</li>
<li><code>std::transform(first, last, output, uop)</code>: perform the given unary operation on the input range and store the result in the output iterator.</li>
<li><code>std::minmax_element(first, last, [cmp])</code>: returns a pair of iterators to the minimum and maximum elements according to the optional comparison function.</li>
<li><code>std::all_of(first, last, predicate)</code>: returns true if all elements evaluate to true.</li>
<li><code>std::lower_bound(first, last, value, [cmp])</code>: returns an iterator to the first value less than or equal the given one in a sorted range.</li>
<li><code>std::upper_bound(first, last, value, [cmp])</code>: returns an iterator to the first value greater than the given one in a sorted range.</li>
<li><code>std::binary_search(first, last, value, [cmp])</code>: returns true if the given value is found in a sorted range.</li>
<li><code>std::count(first, last, value)</code>: count occurrences of the given value in the range.</li>
<li><code>std::count_if(first, last, predicate)</code>: count values for which the predicate returns true in the given range.</li>
</ul>

<h2 id="stl-modifying-algorithms">STL Modifying Algorithms</h2>

<ul>
<li><code>std::iota(first, last, initial)</code>: fill a range with incrementing values.</li>
<li><code>std::fill(first, last, value)</code>: fill a range with the given value.</li>
<li><code>std::generate(first, last, generator)</code>: fill a range with calls to a given generator.</li>
<li><code>std::generate_n(first, count, generator)</code>: write a number of values via calls to a given generator.</li>
<li><code>std::sort(first, last, [cmp])</code>: sort a random-access collection, optionally with a comparator.</li>
<li><code>std::partial_sort(first, middle, last, [cmp])</code>: move the smallest elements in a random-access collection to the area pointed to by first and middle, optionally with a comparator.</li>
<li><code>std::partial_sort_copy(first, middle, last, dest_first, dest_last, [cmp])</code>: like <code>partial_sort</code>, but copy the elements to a target range.</li>
<li><code>std::nth_element(first, nth, last, [cmp])</code>: move the nth-smallest element to the location pointed to by <code>nth</code>.</li>
<li><code>std::stable_sort(first, last, [cmp])</code>: sort a random-access collection while preserving the order of equivalent elements, optionally with a comparator.</li>
<li><code>std::shuffle(first, last, rng)</code>: shuffle a random-access collection.</li>
<li><code>std::remove_if(first, last, predicate)</code>: remove elements that match the predicate.</li>
<li><code>std::remove(first, last, value)</code>: remove elements that equal the value.</li>
<li><code>std::partition(first, last, predicate)</code>: moves elements to the left or right of the container based on the predicate and returns the pivot.</li>
<li><code>std::stable_partition(first, last, predicate)</code>: like <code>partition</code>, but preserves the relative order of elements.</li>
</ul>

<h2 id="random">Random</h2>

<ul>
<li><code>std::mt19937{seed}</code>: the Mersene Twister pseudorandom number generator suitable for insecure number generation.</li>
<li><code>std::uniform_real_distribution&lt;T&gt;{min, max}</code>: range of real numbers with equal probability.</li>
<li><code>std::uniform_int_distribution&lt;T&gt;{min, max}</code>: sequence of integers with equal probability.</li>
<li><code>std::normal_distribution{mean, stddev}</code>: a normal distribution.</li>
<li><code>std::sample(first, last, out, n, rng)</code>: samples N items without replacement and write them to the output.</li>
<li><code>std::generate_canonical(rng)</code>: generates a random value between 0 and 1.</li>
</ul>

<h2 id="variants-and-optional">Variants and optional</h2>

<ul>
<li><code>std::holds_alternative&lt;T&gt;(variant)</code>: returns true if the variant holds a value of the given type.</li>
<li><code>std::get&lt;T&gt;(variant)</code>: return the variant value assuming it holds the given type.</li>
<li><code>std::get_if&lt;T&gt;(variant)</code>: returns a pointer to the variant value assuming it holds the given type, or <code>nullptr</code> otherwise.</li>
<li><code>std::visit(function, variant)</code>: call a function or other callable with the variant's value.</li>
<li><code>std::monostate</code>: type to use as the first type in a variant when the "real" first type is not default constructible.</li>
<li><code>optional.has_value()</code>: returns true if the optional is not <code>std::nullopt</code>.</li>
</ul>

<h2 id="iterators">Iterators</h2>

<ul>
<li><code>std::distance(first, last)</code>: returns a difference value representing the distance between the iterators.</li>
<li><code>std::advance(iter, n)</code>: effectively increment an iterator N times.</li>
<li><code>std::next(iter, n)</code>: returns an iterator N steps ahead of the given one.</li>
<li><code>std::prev(iter, n)</code>: returns an iterator N steps behind the given one.</li>
<li><code>std::back_insert_iterator{container}</code> or <code>std::back_inserter(container)</code>: an output iterator that calls <code>push_back</code> on the container.</li>
<li><code>std::front_insert_iterator{container}</code> or <code>std::front_inserter(container)</code>: an output iterator that calls <code>push_front</code> on the container.</li>
<li><code>std::insert_iterator{container, iter}</code> or <code>std::inserter(container, iter)</code>: an output iterator that starts inserting at the given iterator.</li>
</ul>

<h3 id="iterator-concept">Iterator concept</h3>

<p>Iterator types should have <code>difference_type</code>, <code>value_type</code>, <code>pointer</code> (void if not wanted), <code>reference</code>, and <code>iterator_category</code> defined.</p>

<p>The iterator category tags are:</p>

<ul>
<li><code>std::input_iterator_tag</code>: Can be read and only moved forward.</li>
<li><code>std::output_iterator_tag</code>: Can be written to and only moved forward.</li>
<li><code>std::forward_iterator_tag</code>: Like an input iterator, but can also be copied and used to read the container multiple times.</li>
<li><code>std::bidirectional_iterator_tag</code>: Like a forward iterator, but can move in both directions.</li>
<li><code>std::random_access_iterator_tag</code>: Can be moved forward and back an arbitrary amount to reach any element in the container.</li>
</ul>

<h2 id="threading">Threading</h2>

<ul>
<li><code>std::this_thread::sleep_for(chrono_time)</code>: sleep for the given duration.</li>
</ul>

    <footer>
    <p class="generated_date">Generated on November 10 2025</p>
    </footer>
    </article>
    </div>
    </div>
    </div>
    <script src="script.js"></script>
    </body>
    </html>
    